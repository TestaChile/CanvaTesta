<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>testa_canvas</title>
  <style>
    /* Fondo gris para toda la página */
    html, body {
      height: 100%;
      margin: 0;
      background: #d0d0d0; /* gris */
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Contenedor que usa flex para centrar siempre el lienzo */
    .stage {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      padding: 2vh 2vw; /* margen interior para que no toque bordes muy pequeños */
    }

    /* Wrapper para controlar el tamaño del canvas manteniendo la proporción vertical
       NOTA: asumí "posición vertical" como orientación portrait (más alto que ancho).
       Por eso uso aspecto 9/16 (ancho:alto = 9:16). Si prefieres 16:9 landscape, dímelo
       y ajusto a 16/9. */
    .canvas-wrap {
      /* No forzamos un tamaño absoluto: el JS calculará el máximo que encaje en la ventana */
      display: block;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    }

    /* El canvas no tendrá esquinas redondeadas */
    canvas {
      display: block;
      width: 100%;
      height: auto; /* el tamaño real lo fija el wrapper / JS */
      border-radius: 0 !important;
      background: #ffffff; /* fondo del lienzo blanco, puede cambiarse */
      image-rendering: optimizeQuality;
    }

    /* Mensaje pequeño cuando el canvas no es soportado */
    .fallback {
      color: #333;
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }

    /* Toggle pequeño en la esquina superior izquierda */
    #colorToggle {
      position: fixed;
      top: 8px;
      left: 8px;
      width: 15px;
      height: 15px;
      padding: 0;
      margin: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-family: Consolas, monospace;
      font-weight: 700;
      font-size: 12px; /* ajuste para que la letra quede centrada en 15x15 */
      line-height: 1;
      border: none;
      background: #000; /* fondo negro */
      color: #fff; /* letra blanca */
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    @media (prefers-reduced-motion: reduce) {
      .stage { transition: none; }
    }
  </style>
</head>
<body>
  <button id="colorToggle" aria-label="Seleccionar color del lienzo" title="Seleccionar color del lienzo">C</button>
  <input id="colorPicker" type="color" value="#ffffff" style="display:none;" aria-hidden="true" />
  <div class="stage">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="testa_canvas" aria-label="Lienzo testa_canvas">Tu navegador no soporta canvas.</canvas>
      <!-- fallback eliminado: no se muestra el tamaño -->
    </div>
  </div>

  <script>
    (function() {
      // Configuración: relación de aspecto.
      // Asunción: "posición vertical" -> portrait (ancho:alto = 9:16)
      // Si quieres landscape (16:9), cambia ratio = 16/9.
      const ratio = 9 / 16; // ancho / alto

  const canvas = document.getElementById('testa_canvas');
  const wrap = document.getElementById('canvasWrap');
  const toggle = document.getElementById('colorToggle');
  const colorPicker = document.getElementById('colorPicker');
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  // Color actual del lienzo (value por defecto del input)
  let currentColor = (colorPicker && colorPicker.value) || '#ffffff';

      function resizeCanvasToFit() {
        // Espacio disponible en viewport (con pequeño padding, 95% para evitar tocar bordes)
        const availW = Math.max(100, window.innerWidth * 0.95);
        const availH = Math.max(100, window.innerHeight * 0.95);

        // Calcular el tamaño máximo que cabe manteniendo ratio
        // si availW / availH > ratio significa que hay relativamente más ancho -> usar altura completa
        let width, height;
        if (availW / availH > ratio) {
          // limit by height
          height = availH;
          width = Math.round(height * ratio);
        } else {
          // limit by width
          width = availW;
          height = Math.round(width / ratio);
        }

        // Aplicar tamaño CSS al wrapper para que el canvas escale proporcionalmente
        wrap.style.width = width + 'px';
        wrap.style.height = height + 'px';

        // Ajustes de pixeles reales para alta densidad de píxeles
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        canvas.width = Math.round(width * dpr);
        canvas.height = Math.round(height * dpr);

        // Escalar contexto para mapear coordenadas CSS a píxeles físicos
        const ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          // Dibujar un ejemplo (puedes eliminar o modificar): marco sutil
          ctx.clearRect(0, 0, width, height);
          // Usar el color seleccionado para el fondo del canvas
          ctx.fillStyle = currentColor || '#ffffff';
          ctx.fillRect(0, 0, width, height);

          // Dibujar una guía: un rectángulo sutil dentro del lienzo
          ctx.strokeStyle = 'rgba(0,0,0,0.08)';
          ctx.lineWidth = 1;
          ctx.strokeRect(0.5, 0.5, width-1, height-1);
        }

        // actualizar background CSS (por si el navegador no pinta inmediatamente)
        canvas.style.background = currentColor;
      }

      // Debounce resize to avoid demasiadas repintadas
      let resizeTimer = null;
      function handleResize() {
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          resizeCanvasToFit();
          resizeTimer = null;
        }, 60);
      }

      window.addEventListener('resize', handleResize);
      window.addEventListener('orientationchange', handleResize);

      // Inicializar
      resizeCanvasToFit();
      // Abrir selector de color nativo al pulsar el botón
      function openColorPicker() {
        if (colorPicker) colorPicker.click();
      }

      if (toggle) {
        toggle.addEventListener('click', openColorPicker);
        // permitir activar con tecla Enter/Space por accesibilidad
        toggle.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            openColorPicker();
          }
        });
      }

      // Cuando el usuario selecciona un color, actualizar y repintar
      if (colorPicker) {
        colorPicker.addEventListener('input', (e) => {
          currentColor = e.target.value || '#ffffff';
          resizeCanvasToFit();
        });
        // también escuchar change por compatibilidad
        colorPicker.addEventListener('change', (e) => {
          currentColor = e.target.value || '#ffffff';
          resizeCanvasToFit();
        });
      }

      // Exponer función en window para posibles pruebas manuales
      window.responsiveTestaCanvas = resizeCanvasToFit;
    })();
  </script>
</body>
</html>
