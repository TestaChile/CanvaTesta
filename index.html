<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>testa_canvas</title>
  <style>
    /* Fondo gris para toda la página */
    html, body {
      height: 100%;
      margin: 0;
      background: #d0d0d0; /* gris */
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    /* Contenedor que usa flex para centrar siempre el lienzo */
    .stage {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      padding: 2vh 2vw; /* margen interior para que no toque bordes muy pequeños */
    }

    /* Wrapper para controlar el tamaño del canvas manteniendo la proporción vertical
       NOTA: asumí "posición vertical" como orientación portrait (más alto que ancho).
       Por eso uso aspecto 9/16 (ancho:alto = 9:16). Si prefieres 16:9 landscape, dímelo
       y ajusto a 16/9. */
    .canvas-wrap {
      /* No forzamos un tamaño absoluto: el JS calculará el máximo que encaje en la ventana */
      display: block;
      box-shadow: 0 2px 10px rgba(0,0,0,0.08);
    }

    /* El canvas no tendrá esquinas redondeadas */
    canvas {
      display: block;
      width: 100%;
      height: auto; /* el tamaño real lo fija el wrapper / JS */
      border-radius: 0 !important;
      background: #ffffff; /* fondo del lienzo blanco, puede cambiarse */
      image-rendering: optimizeQuality;
    }

    /* Mensaje pequeño cuando el canvas no es soportado */
    .fallback {
      color: #333;
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.9rem;
    }

    /* Controles (botones) agrupados en la esquina superior izquierda */
    #controls {
      position: fixed;
      top: 8px;
      left: 8px;
      display: inline-flex;
      gap: 8px;
      z-index: 1000;
    }

    /* Estilo común de botones pequeños */
    #controls button {
      width: 15px;
      height: 15px;
      padding: 0;
      margin: 0;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-family: Consolas, monospace;
      font-weight: 700;
      font-size: 12px; /* ajuste para que la letra quede centrada en 15x15 */
      line-height: 1;
      border: none;
      background: #000; /* fondo negro */
      color: #fff; /* letra blanca */
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      border-radius: 4px; /* ligera redondez en esquinas */
    }

    /* (El botón fullscreen usa el estilo común en #controls button) */

    @media (prefers-reduced-motion: reduce) {
      .stage { transition: none; }
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="colorToggle" aria-label="Seleccionar color del lienzo" title="Seleccionar color del lienzo">C</button>
    <input id="colorPicker" type="color" value="#ffffff" style="display:none;" aria-hidden="true" />
    <button id="fullscreenBtn" aria-label="Pantalla completa" title="Ver en pantalla completa">P</button>
  </div>
  <div class="stage">
    <div class="canvas-wrap" id="canvasWrap">
      <canvas id="testa_canvas" aria-label="Lienzo testa_canvas">Tu navegador no soporta canvas.</canvas>
      <!-- fallback eliminado: no se muestra el tamaño -->
    </div>
  </div>

  <script>
    (function() {
      // Configuración: relación de aspecto.
      // Asunción: "posición vertical" -> portrait (ancho:alto = 9:16)
      // Si quieres landscape (16:9), cambia ratio = 16/9.
      const ratio = 9 / 16; // ancho / alto

  const canvas = document.getElementById('testa_canvas');
  const wrap = document.getElementById('canvasWrap');
  const toggle = document.getElementById('colorToggle');
  const colorPicker = document.getElementById('colorPicker');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const dpr = Math.max(1, window.devicePixelRatio || 1);

  // Color actual del lienzo (value por defecto del input)
  let currentColor = (colorPicker && colorPicker.value) || '#ffffff';

  // Detectar dispositivo táctil para modificar comportamiento del botón C
  const isTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
  // Paleta predefinida para dispositivos táctiles (al presionar cicla colores)
  const touchPalette = ['#ffffff', '#e6f7ff', '#ffe6e6', '#e6ffe6', '#fff7e6'];
  let touchIndex = 0;

      function resizeCanvasToFit() {
        // Espacio disponible en viewport (con pequeño padding, 95% para evitar tocar bordes)
        const availW = Math.max(100, window.innerWidth * 0.95);
        const availH = Math.max(100, window.innerHeight * 0.95);

        // Calcular el tamaño máximo que cabe manteniendo ratio
        // si availW / availH > ratio significa que hay relativamente más ancho -> usar altura completa
        let width, height;
        if (availW / availH > ratio) {
          // limit by height
          height = availH;
          width = Math.round(height * ratio);
        } else {
          // limit by width
          width = availW;
          height = Math.round(width / ratio);
        }

        // Aplicar tamaño CSS al wrapper para que el canvas escale proporcionalmente
        wrap.style.width = width + 'px';
        wrap.style.height = height + 'px';

        // Ajustes de pixeles reales para alta densidad de píxeles
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        canvas.width = Math.round(width * dpr);
        canvas.height = Math.round(height * dpr);

        // Escalar contexto para mapear coordenadas CSS a píxeles físicos
        const ctx = canvas.getContext('2d');
        if (ctx) {
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          // Dibujar un ejemplo (puedes eliminar o modificar): marco sutil
          ctx.clearRect(0, 0, width, height);
          // Usar el color seleccionado para el fondo del canvas
          ctx.fillStyle = currentColor || '#ffffff';
          ctx.fillRect(0, 0, width, height);

          // Dibujar una guía: un rectángulo sutil dentro del lienzo
          ctx.strokeStyle = 'rgba(0,0,0,0.08)';
          ctx.lineWidth = 1;
          ctx.strokeRect(0.5, 0.5, width-1, height-1);
        }

        // actualizar background CSS (por si el navegador no pinta inmediatamente)
        canvas.style.background = currentColor;
      }

      // Debounce resize to avoid demasiadas repintadas
      let resizeTimer = null;
      function handleResize() {
        if (resizeTimer) clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          resizeCanvasToFit();
          resizeTimer = null;
        }, 60);
      }

      window.addEventListener('resize', handleResize);
      window.addEventListener('orientationchange', handleResize);

      // Inicializar
      resizeCanvasToFit();
      // Comportamiento del botón C:
      // - En dispositivos no-táctiles abre el selector nativo
      // - En dispositivos táctiles cicla entre colores predefinidos para evitar abrir el picker problemático
      function handleColorButton() {
        if (isTouch) {
          touchIndex = (touchIndex + 1) % touchPalette.length;
          currentColor = touchPalette[touchIndex];
          if (colorPicker) colorPicker.value = currentColor;
          resizeCanvasToFit();
        } else {
          if (colorPicker) colorPicker.click();
        }
      }

      if (toggle) {
        toggle.addEventListener('click', handleColorButton);
        // permitir activar con tecla Enter/Space por accesibilidad
        toggle.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            handleColorButton();
          }
        });
      }

      // --- Fullscreen control ---
      function isFullscreen() {
        return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
      }

      function requestFullscreen(el) {
        if (!el) el = document.documentElement;
        if (el.requestFullscreen) return el.requestFullscreen();
        if (el.webkitRequestFullscreen) return el.webkitRequestFullscreen();
        if (el.msRequestFullscreen) return el.msRequestFullscreen();
        return Promise.reject(new Error('Fullscreen API no soportada'));
      }

      function exitFullscreen() {
        if (document.exitFullscreen) return document.exitFullscreen();
        if (document.webkitExitFullscreen) return document.webkitExitFullscreen();
        if (document.msExitFullscreen) return document.msExitFullscreen();
        return Promise.reject(new Error('Fullscreen API no soportada'));
      }

      function toggleFullscreen() {
        if (isFullscreen()) {
          exitFullscreen().catch(() => {});
        } else {
          // Pedimos fullscreen sobre el wrapper para mantener proporción
          requestFullscreen(wrap).catch(() => {
            // como fallback, sobre el documentElement
            requestFullscreen(document.documentElement).catch(() => {});
          });
        }
      }

      // Actualiza el estado del botón cuando cambia fullscreen
      function onFullscreenChange() {
        const fs = isFullscreen();
        if (fullscreenBtn) fullscreenBtn.setAttribute('aria-pressed', fs ? 'true' : 'false');
        // repintar canvas para ajustar tamaño en fullscreen
        setTimeout(resizeCanvasToFit, 60);
      }

      if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', toggleFullscreen);
        fullscreenBtn.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggleFullscreen();
          }
        });
      }

      document.addEventListener('fullscreenchange', onFullscreenChange);
      document.addEventListener('webkitfullscreenchange', onFullscreenChange);
      document.addEventListener('msfullscreenchange', onFullscreenChange);

      // Cuando el usuario selecciona un color, actualizar y repintar
      if (colorPicker) {
        colorPicker.addEventListener('input', (e) => {
          currentColor = e.target.value || '#ffffff';
          resizeCanvasToFit();
        });
        // también escuchar change por compatibilidad
        colorPicker.addEventListener('change', (e) => {
          currentColor = e.target.value || '#ffffff';
          resizeCanvasToFit();
        });
      }

      // Exponer función en window para posibles pruebas manuales
      window.responsiveTestaCanvas = resizeCanvasToFit;
    })();
  </script>
</body>
</html>
